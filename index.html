<!DOCTYPE html>
<html>
<head>
    <title>Bubble Shooter Premium</title>
    <meta charset="UTF-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        #canvas {
            background: linear-gradient(to bottom, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #fff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        
        #score {
            color: white;
            font-size: 28px;
            font-weight: bold;
            margin: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">Score: 0</div>
        <canvas id="canvas" width="400" height="600"></canvas>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        
        let score = 0;
        let bubbles = [];
        let shooter = { x: canvas.width / 2, y: canvas.height - 30, radius: 15, color: null };
        let angle = -Math.PI / 2;
        let shooting = false;
        let shooterBubble = null;
        let bgOffset = 0;
        
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
        const emojis = ['üòÄ', 'üòé', 'ü•≥', 'üòç', 'ü§©', 'üòú', 'ü§ó', 'üòä'];
        
        class Bubble {
            constructor(x, y, color, emoji) {
                this.x = x;
                this.y = y;
                this.radius = 15;
                this.color = color;
                this.emoji = emoji;
                this.vx = 0;
                this.vy = 0;
                this.opacity = 1;
                this.scale = 1;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                
                // Gradient bubble
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.7, this.color);
                gradient.addColorStop(1, 'rgba(0,0,0,0.3)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Shine effect
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.arc(-5, -5, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Emoji - BIGGER!
                ctx.font = 'bold 35px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                
                ctx.restore();
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
            }
            
            popAnimation() {
                this.scale += 0.15;
                this.opacity -= 0.1;
                return this.opacity <= 0;
            }
        }
        
        function drawBackground() {
            // Animated stars background
            bgOffset += 0.2;
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0f0c29');
            gradient.addColorStop(0.5, '#302b63');
            gradient.addColorStop(1, '#24243e');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stars
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            for (let i = 0; i < 50; i++) {
                const x = (i * 97 + bgOffset * 2) % canvas.width;
                const y = (i * 71) % canvas.height;
                const size = (i % 3) * 0.5 + 0.5;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function init() {
            // Create initial bubble grid
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 8; col++) {
                    const x = col * 50 + 25 + (row % 2) * 25;
                    const y = row * 43 + 30;
                    const colorIndex = Math.floor(Math.random() * colors.length);
                    bubbles.push(new Bubble(x, y, colors[colorIndex], emojis[colorIndex]));
                }
            }
            newShooterBubble();
        }
        
        function newShooterBubble() {
            const colorIndex = Math.floor(Math.random() * colors.length);
            shooter.color = colors[colorIndex];
            shooter.emoji = emojis[colorIndex];
        }
        
        function drawShooter() {
            // Arrow line
            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(255,255,255,0.5)';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(shooter.x, shooter.y);
            ctx.lineTo(shooter.x + Math.cos(angle) * 60, shooter.y + Math.sin(angle) * 60);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Shooter bubble
            const gradient = ctx.createRadialGradient(shooter.x, shooter.y, 0, shooter.x, shooter.y, shooter.radius);
            gradient.addColorStop(0, shooter.color);
            gradient.addColorStop(1, 'rgba(0,0,0,0.3)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(shooter.x, shooter.y, shooter.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Emoji - BIGGER!
            ctx.font = 'bold 35px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(shooter.emoji, shooter.x, shooter.y);
        }
        
        function shoot() {
            if (shooting) return;
            shooting = true;
            shooterBubble = new Bubble(shooter.x, shooter.y, shooter.color, shooter.emoji);
            shooterBubble.vx = Math.cos(angle) * 10;
            shooterBubble.vy = Math.sin(angle) * 10;
        }
        
        function checkCollision() {
            if (!shooterBubble) return;
            
            // Wall collision
            if (shooterBubble.x <= shooterBubble.radius || shooterBubble.x >= canvas.width - shooterBubble.radius) {
                shooterBubble.vx *= -1;
            }
            
            // Bubble collision
            for (let bubble of bubbles) {
                const dx = shooterBubble.x - bubble.x;
                const dy = shooterBubble.y - bubble.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < shooterBubble.radius * 2) {
                    // Snap to grid
                    const row = Math.round(bubble.y / 43);
                    const col = Math.round((bubble.x - (row % 2) * 25) / 50);
                    shooterBubble.x = col * 50 + 25 + (row % 2) * 25;
                    shooterBubble.y = row * 43 + 30;
                    shooterBubble.vx = 0;
                    shooterBubble.vy = 0;
                    
                    bubbles.push(shooterBubble);
                    checkMatches(shooterBubble);
                    shooterBubble = null;
                    shooting = false;
                    newShooterBubble();
                    return;
                }
            }
            
            // Top collision
            if (shooterBubble.y <= shooterBubble.radius) {
                const row = 0;
                const col = Math.round((shooterBubble.x - (row % 2) * 25) / 50);
                shooterBubble.x = col * 50 + 25 + (row % 2) * 25;
                shooterBubble.y = 30;
                shooterBubble.vx = 0;
                shooterBubble.vy = 0;
                bubbles.push(shooterBubble);
                checkMatches(shooterBubble);
                shooterBubble = null;
                shooting = false;
                newShooterBubble();
            }
        }
        
        function checkMatches(newBubble) {
            const matches = [newBubble];
            const checked = new Set();
            const toCheck = [newBubble];
            
            while (toCheck.length > 0) {
                const current = toCheck.pop();
                checked.add(current);
                
                for (let bubble of bubbles) {
                    if (checked.has(bubble)) continue;
                    
                    const dx = current.x - bubble.x;
                    const dy = current.y - bubble.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < current.radius * 2.2 && bubble.color === newBubble.color) {
                        matches.push(bubble);
                        toCheck.push(bubble);
                        checked.add(bubble);
                    }
                }
            }
            
            if (matches.length >= 3) {
                // Pop animation
                let popCount = 0;
                const popInterval = setInterval(() => {
                    for (let bubble of matches) {
                        if (bubble.popAnimation()) {
                            popCount++;
                        }
                    }
                    
                    if (popCount >= matches.length) {
                        clearInterval(popInterval);
                        bubbles = bubbles.filter(b => !matches.includes(b));
                        score += matches.length * 10;
                        scoreEl.textContent = 'Score: ' + score;
                    }
                }, 50);
            }
        }
        
        function gameLoop() {
            // Beautiful animated background instead of clearRect
            drawBackground();
            
            // Draw all bubbles
            for (let bubble of bubbles) {
                bubble.draw();
            }
            
            // Draw and update shooter bubble
            if (shooterBubble) {
                shooterBubble.update();
                shooterBubble.draw();
                checkCollision();
            }
            
            drawShooter();
            
            requestAnimationFrame(gameLoop);
        }
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            angle = Math.atan2(mouseY - shooter.y, mouseX - shooter.x);
            
            // Limit angle
            if (angle > Math.PI / 6) angle = Math.PI / 6;
            if (angle < -Math.PI + Math.PI / 6) angle = -Math.PI + Math.PI / 6;
        });
        
        canvas.addEventListener('click', shoot);
        
        init();
        gameLoop();
    </script>
</body>
</html>
