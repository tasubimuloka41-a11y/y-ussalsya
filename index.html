<!DOCTYPE html><html><head><meta charset="UTF-8"><title>üéÆ BUBBLE SHOOTER PREMIUM</title><style>*{margin:0;padding:0;box-sizing:border-box}body{display:flex;justify-content:center;align-items:center;min-height:100vh;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);font-family:'Arial',sans-serif;overflow:hidden}#gameContainer{position:relative;width:min(480px,100vw);height:min(800px,100vh);background:#fff;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,0.3);overflow:hidden}#scorePanel{position:absolute;top:0;left:0;right:0;height:60px;background:linear-gradient(180deg,rgba(0,0,0,0.8) 0%,rgba(0,0,0,0) 100%);display:flex;justify-content:space-around;align-items:center;z-index:1000;padding:10px 20px}.score-item{display:flex;flex-direction:column;align-items:center;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.5)}.score-label{font-size:12px;opacity:0.8}.score-value{font-size:24px;font-weight:bold}#canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#87CEEB 0%,#E0F6FF 100%)}#gameOverModal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);padding:40px;border-radius:20px;text-align:center;display:none;z-index:2000;animation:slideIn 0.3s ease-out}#gameOverModal h1{color:#ff4757;font-size:48px;margin-bottom:20px;text-shadow:0 0 20px rgba(255,71,87,0.5)}#gameOverModal p{color:#fff;font-size:18px;margin:10px 0}#restartBtn{background:linear-gradient(135deg,#ff6b6b,#ee5a24);color:#fff;border:none;padding:15px 40px;font-size:20px;border-radius:50px;cursor:pointer;margin-top:20px;transition:all 0.3s;box-shadow:0 4px 15px rgba(255,107,107,0.4)}#restartBtn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(255,107,107,0.6)}@keyframes slideIn{from{transform:translate(-50%,-60%);opacity:0}to{transform:translate(-50%,-50%);opacity:1}}@media(max-width:480px){#gameContainer{border-radius:0;width:100vw;height:100vh}body{background:#667eea}}</style></head><body><div id="gameContainer"><div id="scorePanel"><div class="score-item"><div class="score-label">–û—á–∫–∏</div><div class="score-value" id="scoreDisplay">0</div></div><div class="score-item"><div class="score-label">–•–æ–¥—ã</div><div class="score-value" id="movesDisplay">30</div></div></div><canvas id="canvas"></canvas><div id="gameOverModal"><h1>GAME OVER!</h1><p>–û—á–∫–∏: <span id="finalScore">0</span></p><p>–†–µ–∫–æ—Ä–¥: <span id="bestScore">0</span></p><button id="restartBtn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button></div></div><script>const canvas=document.getElementById('canvas');const ctx=canvas.getContext('2d');const scoreDisplay=document.getElementById('scoreDisplay');const movesDisplay=document.getElementById('movesDisplay');const gameOverModal=document.getElementById('gameOverModal');const finalScoreEl=document.getElementById('finalScore');const bestScoreEl=document.getElementById('bestScore');const restartBtn=document.getElementById('restartBtn');let W,H,ballR,cols,rows;function resizeCanvas(){const container=document.getElementById('gameContainer');W=container.clientWidth;H=container.clientHeight;canvas.width=W;canvas.height=H;ballR=Math.min(W,H)/25;cols=Math.floor(W/(ballR*2));rows=Math.floor((H-100)/(ballR*1.8))}resizeCanvas();window.addEventListener('resize',()=>{resizeCanvas();initGame()});const colors=['#FF6B9D','#4ECDC4','#FFE66D','#95E1D3','#F38181'];let grid=[];let score=0;let moves=30;let bestScore=localStorage.getItem('bestScore')||0;let currentBall=null;let nextBall=null;let shotCount=0;let offsetY=0;let targetOffsetY=0;function initGame(){grid=[];score=0;moves=30;shotCount=0;offsetY=0;targetOffsetY=0;scoreDisplay.textContent=score;movesDisplay.textContent=moves;bestScoreEl.textContent=bestScore;gameOverModal.style.display='none';for(let row=0;row<5;row++){grid[row]=[];for(let col=0;col<cols;col++){if(row%2===0&&col===cols-1)continue;grid[row][col]={color:colors[Math.floor(Math.random()*colors.length)],x:getX(col,row),y:getY(row)}}}currentBall={color:colors[Math.floor(Math.random()*colors.length)],x:W/2,y:H-50};nextBall={color:colors[Math.floor(Math.random()*colors.length)]};draw()}function getX(col,row){return ballR+(col*ballR*2)+(row%2===1?ballR:0)}function getY(row){return 80+offsetY+(row*ballR*1.8)}function draw(){ctx.clearRect(0,0,W,H);if(Math.abs(offsetY-targetOffsetY)>0.5){offsetY+=(targetOffsetY-offsetY)*0.1;for(let row=0;row<grid.length;row++){for(let col=0;col<grid[row].length;col++){if(grid[row][col])grid[row][col].y=getY(row)}}}for(let row=0;row<grid.length;row++){for(let col=0;col<grid[row].length;col++){if(grid[row][col]){drawBall(grid[row][col].x,grid[row][col].y,grid[row][col].color)}}}if(currentBall){drawBall(currentBall.x,currentBall.y,currentBall.color,true)}requestAnimationFrame(draw)}function drawBall(x,y,color,glow=false){ctx.save();ctx.beginPath();ctx.arc(x,y,ballR,0,Math.PI*2);const gradient=ctx.createRadialGradient(x-ballR/3,y-ballR/3,0,x,y,ballR);gradient.addColorStop(0,'rgba(255,255,255,0.8)');gradient.addColorStop(0.4,color);gradient.addColorStop(1,shadeColor(color,-30));ctx.fillStyle=gradient;ctx.fill();if(glow){ctx.shadowColor=color;ctx.shadowBlur=20}ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.lineWidth=2;ctx.stroke();ctx.restore()}function shadeColor(color,percent){const num=parseInt(color.slice(1),16);const amt=Math.round(2.55*percent);const R=(num>>16)+amt;const G=(num>>8&0x00FF)+amt;const B=(num&0x0000FF)+amt;return'#'+(0x1000000+(R<255?R<1?0:R:255)*0x10000+(G<255?G<1?0:G:255)*0x100+(B<255?B<1?0:B:255)).toString(16).slice(1)}canvas.addEventListener('click',e=>{if(!currentBall||gameOverModal.style.display==='block')return;const rect=canvas.getBoundingClientRect();const clickX=e.clientX-rect.left;const clickY=e.clientY-rect.top;shoot(clickX,clickY)});function shoot(targetX,targetY){const dx=targetX-currentBall.x;const dy=targetY-currentBall.y;const dist=Math.sqrt(dx*dx+dy*dy);const vx=(dx/dist)*20;const vy=(dy/dist)*20;const shootingBall={...currentBall,vx,vy};animateShot(shootingBall)}function animateShot(ball){const interval=setInterval(()=>{ball.x+=ball.vx;ball.y+=ball.vy;if(ball.x<=ballR||ball.x>=W-ballR){ball.vx*=-1;ball.x=ball.x<=ballR?ballR:W-ballR}let collided=false;for(let row=0;row<grid.length&&!collided;row++){for(let col=0;col<grid[row].length&&!collided;col++){if(grid[row][col]){const dx=ball.x-grid[row][col].x;const dy=ball.y-grid[row][col].y;const dist=Math.sqrt(dx*dx+dy*dy);if(dist<ballR*1.8){clearInterval(interval);snapToGrid(ball,row,col);collided=true}}}}if(ball.y<=80+offsetY&&!collided){clearInterval(interval);snapToGrid(ball,0,Math.round((ball.x-ballR)/ballR/2))}},16)}function snapToGrid(ball,nearRow,nearCol){let bestRow=nearRow;let bestCol=nearCol;let minDist=Infinity;for(let row=Math.max(0,nearRow-1);row<=Math.min(grid.length-1,nearRow+1);row++){for(let col=Math.max(0,nearCol-1);col<=Math.min(cols-1,nearCol+1);col++){if(row%2===0&&col===cols-1)continue;if(!grid[row]||grid[row][col])continue;const gx=getX(col,row);const gy=getY(row);const dist=Math.sqrt((ball.x-gx)**2+(ball.y-gy)**2);if(dist<minDist){minDist=dist;bestRow=row;bestCol=col}}}if(!grid[bestRow])grid[bestRow]=[];grid[bestRow][bestCol]={color:ball.color,x:getX(bestCol,bestRow),y:getY(bestRow)};checkMatches(bestRow,bestCol);removeFloating();moves--;movesDisplay.textContent=moves;shotCount++;if(shotCount>=5){shotCount=0;addNewRow()}currentBall={color:nextBall.color,x:W/2,y:H-50};nextBall={color:colors[Math.floor(Math.random()*colors.length)]};checkGameOver()}function checkMatches(row,col){const color=grid[row][col].color;const matched=new Set();const toCheck=[[row,col]];matched.add(`${row},${col}`);while(toCheck.length){const[r,c]=toCheck.pop();const neighbors=getNeighbors(r,c);for(const[nr,nc]of neighbors){const key=`${nr},${nc}`;if(!matched.has(key)&&grid[nr]&&grid[nr][nc]&&grid[nr][nc].color===color){matched.add(key);toCheck.push([nr,nc])}}}if(matched.size>=3){matched.forEach(key=>{const[r,c]=key.split(',').map(Number);grid[r][c]=null});score+=matched.size*10;scoreDisplay.textContent=score}}function getNeighbors(row,col){const even=row%2===0;const offsets=even?[[-1,0],[-1,-1],[0,-1],[0,1],[1,-1],[1,0]]:[[-1,1],[-1,0],[0,-1],[0,1],[1,0],[1,1]];return offsets.map(([dr,dc])=>[row+dr,col+dc]).filter(([r,c])=>r>=0&&r<grid.length&&c>=0&&c<cols)}function removeFloating(){const connected=new Set();const toCheck=[];for(let col=0;col<cols;col++){if(grid[0]&&grid[0][col]){connected.add(`0,${col}`);toCheck.push([0,col])}}while(toCheck.length){const[r,c]=toCheck.pop();const neighbors=getNeighbors(r,c);for(const[nr,nc]of neighbors){const key=`${nr},${nc}`;if(!connected.has(key)&&grid[nr]&&grid[nr][nc]){connected.add(key);toCheck.push([nr,nc])}}}for(let row=0;row<grid.length;row++){for(let col=0;col<cols;col++){if(grid[row]&&grid[row][col]&&!connected.has(`${row},${col}`)){grid[row][col]=null;score+=5;scoreDisplay.textContent=score}}}}function addNewRow(){targetOffsetY+=ballR*1.8;grid.unshift([]);for(let col=0;col<cols;col++){grid[0][col]={color:colors[Math.floor(Math.random()*colors.length)],x:getX(col,0),y:getY(0)}}}function checkGameOver(){for(let row=0;row<grid.length;row++){for(let col=0;col<grid[row].length;col++){if(grid[row][col]&&grid[row][col].y>=H-100){gameOver();return}}}if(moves<=0){let hasBalls=false;for(let row=0;row<grid.length;row++){for(let col=0;col<grid[row].length;col++){if(grid[row][col]){hasBalls=true;break}}if(hasBalls)break}if(hasBalls)gameOver()}}function gameOver(){gameOverModal.style.display='block';finalScoreEl.textContent=score;if(score>bestScore){bestScore=score;localStorage.setItem('bestScore',bestScore);bestScoreEl.textContent=bestScore}}restartBtn.addEventListener('click',initGame);initGame()</script></body></html>
