
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Дурак — одиночная игра (36 карт, подкидной)</title>
<style>
  :root{
    --bg:#0d0f12; --panel:#151922; --text:#eaeef7; --gold:#d6a542;
    --soft:#242a36; --accent:#4c79ff; --shadow:rgba(0,0,0,.35);
    --cardW:92px; --cardH:132px;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif;}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid #222}
  h1{margin:0;color:var(--gold);font-weight:700;letter-spacing:.3px}
  main{padding:16px;display:grid;gap:12px}
  .row{display:grid;grid-template-columns:1fr 340px;gap:12px}
  .panel{background:var(--panel);border-radius:12px;border:1px solid rgba(214,165,66,.25);padding:12px}
  .badge{padding:6px 10px;border:1px solid rgba(214,165,66,.35);border-radius:10px;color:var(--gold)}
  #status{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  #deck{width:var(--cardW);height:var(--cardH);border-radius:8px;
    background:linear-gradient(135deg,#1a1f29,#2b2f3a);
    box-shadow:0 10px 20px var(--shadow); border:1px solid rgba(214,165,66,.35);}
  #controls{display:flex;gap:8px;flex-wrap:wrap;margin-left:12px}
  button{background:linear-gradient(135deg,#2b2f3a,#1a1f29);color:var(--gold);
    border:1px solid rgba(214,165,66,.35);border-radius:10px;padding:8px 12px;cursor:pointer}
  button:disabled{opacity:.4;cursor:not-allowed}
  #board{display:flex;flex-wrap:wrap;gap:10px;min-height:150px;padding:12px;background:var(--soft);
    border-radius:12px;border:1px solid rgba(214,165,66,.2)}
  #hand,#botHand{display:flex;flex-wrap:wrap;gap:10px;min-height:150px;padding:12px;background:var(--soft);
    border-radius:12px;border:1px solid rgba(214,165,66,.2)}
  #botHand .card{filter:grayscale(.75) opacity(.9)}
  .stack{position:relative;width:calc(var(--cardW) + 20px);height:calc(var(--cardH) + 20px)}
  .stack .card{position:absolute;left:10px;top:10px}
  .card{
    position:relative;width:var(--cardW);height:var(--cardH);
    background:#fafafa;border-radius:8px;border:1px solid #ccc;
    box-shadow:0 12px 24px var(--shadow);
    transition:transform .2s ease, box-shadow .2s ease, opacity .2s ease; user-select:none;
  }
  .card:hover{transform:translateY(-4px); box-shadow:0 18px 30px rgba(0,0,0,.5)}
  .card.red{color:#cc2a2a} .card.black{color:#111}
  .pip{position:absolute}
  .rankTop{left:8px;top:6px;font-weight:700}
  .suitTop{left:10px;top:28px;font-size:14px}
  .center{left:50%;top:50%;transform:translate(-50%,-50%);font-size:28px;opacity:.85}
  .rankBot{right:8px;bottom:28px;font-weight:700}
  .suitBot{right:10px;bottom:6px;font-size:14px}
  .disabled{opacity:.35;pointer-events:none}
  .selectable{outline:2px dashed rgba(214,165,66,.5)}
  .dealing{opacity:0; transform:scale(.95)}
  #log{max-height:220px;overflow:auto;font-size:13px}
  #end{font-weight:700;color:var(--gold);margin-top:6px}
  .small{opacity:.8;font-size:12px}
  @media (max-width:900px){ .row{grid-template-columns:1fr} }
</style>
</head>
<body>
<header>
  <h1>Дурак — одиночная (подкидной, 36 карт)</h1>
  <div><button id="newGame">Новая игра</button></div>
</header>

<main class="row">
  <section class="panel">
    <div id="status">
      <span id="trump" class="badge">Козырь: —</span>
      <span id="turn"  class="badge">Ход: —</span>
      <span id="talon" class="badge">Талон: 36</span>
      <span id="phase" class="badge small">Фаза: —</span>
    </div>
    <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
      <div id="deck" title="Колода/талон"></div>
      <div id="controls">
        <button id="btnAttack" disabled>Атаковать</button>
        <button id="btnThrow"  disabled>Подкинуть</button>
        <button id="btnDefend" disabled>Защитить</button>
        <button id="btnTake"   disabled>Взять</button>
        <button id="btnPass"   disabled>Отбой</button>
      </div>
    </div>

    <h3 style="margin:8px 0">Стол</h3>
    <div id="board"></div>

    <h3 style="margin:12px 0">Моя рука</h3>
    <div id="hand"></div>

    <h3 style="margin:12px 0">Рука бота</h3>
    <div id="botHand"></div>
  </section>

  <aside class="panel">
    <div><strong>Бот</strong> играет корректно: минимальные атаки/защиты, старается подкидывать, если это увеличивает шанс заставить взять.</div>
    <div id="end"></div>
    <h3 style="margin-top:16px">Лог</h3>
    <div id="log"></div>
  </aside>
</main>

<script>
/* ================== Константы и утилиты ================== */
const RANKS = ['6','7','8','9','10','J','Q','K','A'];
const SUITS = ['S','H','D','C']; // S♠ H♥ D♦ C♣
const sym = s => ({S:'♠',H:'♥',D:'♦',C:'♣'})[s];
const colorClass = s => (s==='H'||s==='D') ? 'red' : 'black';
const rIndex = r => RANKS.indexOf(r);
function buildDeck(){ const d=[]; for(const s of SUITS) for(const r of RANKS) d.push({r,s,id:`${r}${s}`}); return d; }
function shuffle(a){ for(let i=a.length-1;i>0;i++){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function beats(att, def, trump){
  if(!def) return false;
  if(def.s===att.s && rIndex(def.r)>rIndex(att.r)) return true;
  if(def.s===trump && att.s!==trump) return true;
  return false;
}
function clone(o){ return JSON.parse(JSON.stringify(o)); }

/* ================== Состояние игры ================== */
const ui = {
  newGame:document.querySelector('#newGame'),
  trump:  document.querySelector('#trump'),
  talon:  document.querySelector('#talon'),
  turn:   document.querySelector('#turn'),
  phase:  document.querySelector('#phase'),
  end:    document.querySelector('#end'),
  deck:   document.querySelector('#deck'),
  board:  document.querySelector('#board'),
  hand:   document.querySelector('#hand'),
  botHand:document.querySelector('#botHand'),
  log:    document.querySelector('#log'),
  btnAttack:document.querySelector('#btnAttack'),
  btnThrow: document.querySelector('#btnThrow'),
  btnDefend:document.querySelector('#btnDefend'),
  btnTake:  document.querySelector('#btnTake'),
  btnPass:  document.querySelector('#btnPass'),
};

let G = null; // глобальное состояние

function initGame(){
  const deck = shuffle(buildDeck());
  const trumpCard = deck[deck.length-1];
  const trump = trumpCard.s;

  const you = deck.splice(0,6);
  const bot = deck.splice(0,6);

  // первый ход — владелец минимального козыря
  const minT = hand => hand.filter(c=>c.s===trump).sort((a,b)=>rIndex(a.r)-rIndex(b.r))[0] || {r:'A'};
  const attacker = (rIndex(minT(you).r) < rIndex(minT(bot).r)) ? 'you' : 'bot';

  G = {
    trump, deck, discard: [],
    hands: { you, bot },
    attacker, defender: attacker==='you'?'bot':'you',
    phase: 'attack', // 'attack'|'defense'|'throw'|'refill'
    table: [],       // массив пар: {attack, defense}
    selected: null,  // выбранная карта игрока
    finished:false
  };

  ui.end.textContent = '';
  ui.board.innerHTML = '';
  ui.botHand.innerHTML = '';
  ui.log.innerHTML = '';
  renderHands();
  updateHeader();
  dealAnimation('you'); // анимация раздачи вам
  // Боту "раздаём" без анимации (можно включить аналогично)
  renderBotHand();

  if(G.attacker==='bot') setTimeout(botAttackStart, 600);
}

/* ================== Рендер карты ================== */
function cardEl(card){
  const el = document.createElement('div');
  el.className = `card ${colorClass(card.s)}`;
  el.dataset.id = card.id;
  el.innerHTML = `
    <div class="pip rankTop">${card.r}</div>
    <div class="pip suitTop">${sym(card.s)}</div>
    <div class="pip center">${sym(card.s)}</div>
    <div class="pip rankBot">${card.r}</div>
    <div class="pip suitBot">${sym(card.s)}</div>
  `;
  return el;
}
function renderHands(){
  ui.hand.innerHTML = '';
  G.hands.you.forEach(c=>{
    const el = cardEl(c);
    el.onclick = ()=>onCardClick(c);
    ui.hand.appendChild(el);
  });
}
function renderBotHand(){
  ui.botHand.innerHTML = '';
  G.hands.bot.forEach(c=>{
    const el = cardEl(c);
    el.classList.add('disabled'); // скрываем интерактив
    ui.botHand.appendChild(el);
  });
}
function updateHeader(){
  ui.trump.textContent = `Козырь: ${sym(G.trump)}`;
  ui.turn.textContent  = `Ход: ${G.attacker==='you'?'Вы':'Бот'}`;
  ui.talon.textContent = `Талон: ${G.deck.length}`;
  ui.phase.textContent = `Фаза: ${G.phase}`;
}

/* ================== Анимации ================== */
function dealAnimation(who){
  const deckBox = ui.deck.getBoundingClientRect();
  const list = who==='you' ? Array.from(ui.hand.querySelectorAll('.card')) : Array.from(ui.botHand.querySelectorAll('.card'));
  list.forEach(el=>el.classList.add('dealing'));
  list.forEach((el,i)=>{
    const box = el.getBoundingClientRect();
    const dx = (deckBox.left + deckBox.width/2) - (box.left + box.width/2);
    const dy = (deckBox.top  + deckBox.height/2) - (box.top  + box.height/2);
    el.style.transition = 'transform .45s ease, opacity .45s ease';
    requestAnimationFrame(()=>{
      el.style.transform = `translate(${dx}px,${dy}px) scale(.95)`;
      el.style.opacity = '0';
      setTimeout(()=>{
        el.style.transform = 'translate(0,0) scale(1)';
        el.style.opacity = '1';
        setTimeout(()=>el.classList.remove('dealing'), 200);
      }, 30 + i*120);
    });
  });
}
function flyToBoardFromHand(card){
  const src = ui.hand.querySelector(`[data-id="${card.id}"]`);
  if(!src) return;
  const ghost = src.cloneNode(true);
  document.body.appendChild(ghost);
  const from = src.getBoundingClientRect();
  const to = ui.board.getBoundingClientRect();
  Object.assign(ghost.style,{position:'fixed',left:`${from.left}px`,top:`${from.top}px`,zIndex:'999'});
  const tx = (to.left + 20 + Math.random()*20) - from.left;
  const ty = (to.top  + 20 + Math.random()*15) - from.top;
  ghost.style.transition = 'transform .35s ease';
  requestAnimationFrame(()=>{ ghost.style.transform = `translate(${tx}px,${ty}px) rotate(${(Math.random()*10-5)}deg)`; });
  setTimeout(()=>{ ghost.remove(); },380);
}
function flyToDiscardFromBoard(){
  const els = Array.from(ui.board.querySelectorAll('.card'));
  els.forEach((el,i)=>{
    const b = el.getBoundingClientRect();
    const dx = (ui.deck.getBoundingClientRect().left - b.left);
    const dy = (ui.deck.getBoundingClientRect().top  - b.top );
    el.style.transition = 'transform .35s ease, opacity .35s ease';
    el.style.transform = `translate(${dx}px,${dy}px) rotate(${(Math.random()*20 - 10)}deg) scale(.9)`;
    el.style.opacity = '0';
    setTimeout(()=>el.remove(), 360+i*30);
  });
}

/* ================== Лог ================== */
function log(msg){ const p=document.createElement('div'); p.textContent=msg; ui.log.appendChild(p); ui.log.scrollTop=ui.log.scrollHeight; }

/* ================== Клики игрока ================== */
function onCardClick(card){
  if(G.finished) return;

  const idsOnTable = new Set();
  G.table.forEach(pair=>{
    if(pair.attack) idsOnTable.add(pair.attack.r);
    if(pair.defense) idsOnTable.add(pair.defense.r);
  });

  if(G.phase==='attack' && G.attacker==='you'){
    // первая атакующая
    G.selected = card;
    ui.btnAttack.disabled = false;
    ui.btnThrow.disabled  = true;
    ui.btnDefend.disabled = true;
    ui.btnTake.disabled   = true;
    ui.btnPass.disabled   = true;
    // подсветим пригодные к подкидыванию (после первого удара активируется)
  }
  else if(G.phase==='throw' && G.attacker==='you'){
    // можно подкидывать ранги, уже присутствующие
    const ok = idsOnTable.has(card.r) && G.table.length < G.hands[G.defender].length;
    ui.btnThrow.disabled = !ok;
    G.selected = ok ? card : null;
  }
  else if(G.phase==='defense' && G.defender==='you'){
    // защищаем последнюю не покрытую атаку
    const targetIndex = G.table.findIndex(p => p.attack && !p.defense);
    if(targetIndex<0){ ui.btnDefend.disabled = true; return; }
    const att = G.table[targetIndex].attack;
    const ok = beats(att, card, G.trump);
    ui.btnDefend.disabled = !ok;
    G.selected = ok ? card : null;
  }
}

/* ================== Кнопки игрока ================== */
ui.btnAttack.onclick = ()=> {
  if(!G.selected) return;
  playAttack('you', G.selected);
  ui.btnAttack.disabled = true;
  ui.btnPass.disabled   = true;
  ui.btnTake.disabled   = true;

  if(G.hands[G.defender].length===0){ // редкий случай
    endBout(true); return;
  }
  G.phase = 'defense';
  updateHeader();
  setTimeout(botDefendStep, 600);
};
ui.btnThrow.onclick = ()=> {
  if(!G.selected) return;
  playAttack('you', G.selected, true);
  ui.btnThrow.disabled = true;

  if(G.table.length >= G.hands[G.defender].length){
    // нельзя больше подкидывать
    G.phase = 'defense';
    updateHeader();
    setTimeout(botDefendStep, 600);
  } else {
    // можно ещё подкинуть
    highlightThrowOptions('you');
  }
};
ui.btnDefend.onclick = ()=> {
  if(!G.selected) return;
  playDefense('you', G.selected);
  ui.btnDefend.disabled = true;

  // если все атаки покрыты — у атакующего шанс подкинуть
  if(G.table.every(p=>p.defense)){
    if(canThrow(G.attacker) && G.table.length < G.hands[G.defender].length){
      G.phase = 'throw';
      updateHeader();
      if(G.attacker==='bot') setTimeout(botThrowStep, 500);
      else highlightThrowOptions('you');
    } else {
      // отбой
      endBout(true);
    }
  } else {
    // ещё есть непокрытые атаки — бот продолжает защищаться
    setTimeout(botDefendStep, 500);
  }
};
ui.btnTake.onclick = ()=> {
  defenderTake('you');
};
ui.btnPass.onclick = ()=> {
  // доступно только когда защита удалась и атакующий отказывается подкидывать
  endBout(true);
};

/* ================== Ходы: атака/защита/подкидывание ================== */
function playAttack(who, card, isThrow=false){
  // снять карту с руки
  removeFromHand(who, card);
  flyToBoardFromHand(card);

  if(!isThrow && G.table.length===0){
    G.table.push({attack:card, defense:null});
    log(`${who==='you'?'Вы':'Бот'} атакует: ${card.r}${sym(card.s)}`);
  } else {
    G.table.push({attack:card, defense:null});
    log(`${who==='you'?'Вы':'Бот'} подкидывает: ${card.r}${sym(card.s)}`);
  }
  renderHands(); renderBotHand(); renderTable();
}
function playDefense(who, card){
  const idx = G.table.findIndex(p=>p.attack && !p.defense);
  if(idx<0) return;
  const att = G.table[idx].attack;
  const ok = beats(att,card,G.trump);
  if(!ok) return;

  removeFromHand(who, card);
  flyToBoardFromHand(card);

  G.table[idx].defense = card;
  log(`${who==='you'?'Вы':'Бот'} защитился: ${card.r}${sym(card.s)} против ${att.r}${sym(att.s)}`);
  renderHands(); renderBotHand(); renderTable();

  // если защитник закрыл все атаки, возможно подкидывание
}
function renderTable(){
  ui.board.innerHTML = '';
  G.table.forEach(pair=>{
    const st = document.createElement('div'); st.className='stack';
    st.appendChild(cardEl(pair.attack));
    if(pair.defense) st.appendChild(cardEl(pair.defense));
    ui.board.appendChild(st);
  });
}

/* ================== Бот: логика ================== */
function botAttackStart(){
  if(G.finished) return;
  G.phase='attack'; updateHeader();
  // минимальная не-козырная, затем козырь
  const hand = clone(G.hands.bot).sort((a,b)=>{
    const ta = a.s===G.trump, tb = b.s===G.trump;
    if(ta!==tb) return ta?1:-1;
    return rIndex(a.r)-rIndex(b.r);
  });
  const card = hand[0];
  playAttack('bot', card, false);
  G.phase='defense'; updateHeader();
  highlightDefendOptionsForPlayer();
}
function botDefendStep(){
  if(G.finished) return;
  const idx = G.table.findIndex(p=>!p.defense);
  if(idx<0) return; // все покрыты
  const att = G.table[idx].attack;

  // найти минимальную покрывающую карту
  const options = G.hands.bot.filter(c=>beats(att,c,G.trump))
    .sort((a,b)=>{ // при равенстве — неподкозырные выше приоритета
      const ta = a.s===G.trump, tb=b.s===G.trump;
      if(ta!==tb) return ta?1:-1;
      return rIndex(a.r)-rIndex(b.r);
    });

  if(options.length){
    playDefense('bot', options[0]);
    // если не осталось непокрытых — возможно подкидывание человека
    if(G.table.every(p=>p.defense)){
      if(canThrow('you') && G.table.length < G.hands.you.length){
        G.phase='throw'; updateHeader();
        highlightThrowOptions('you');
      } else {
        endBout(true);
      }
    } else {
      // ещё нужно защищаться
      setTimeout(botDefendStep, 400);
    }
  } else {
    // бот не может покрыть — берёт все
    defenderTake('bot');
  }
}
function botThrowStep(){
  if(!canThrow('bot')) { endBout(true); return; }
  if(G.table.length >= G.hands[G.defender].length) { endBout(true); return; }

  const ranksOnTable = new Set();
  G.table.forEach(p=>{ ranksOnTable.add(p.attack.r); if(p.defense) ranksOnTable.add(p.defense.r); });

  const candidates = G.hands.bot.filter(c=>ranksOnTable.has(c.r))
    .sort((a,b)=>rIndex(a.r)-rIndex(b.r));

  if(candidates.length){
    const card = candidates[0];
    playAttack('bot', card, true);
    if(G.table.length >= G.hands[G.defender].length){
      G.phase='defense'; updateHeader();
      highlightDefendOptionsForPlayer();
    } else {
      // бот может ещё подкинуть, но даём шанс игроку защищаться
      G.phase='defense'; updateHeader();
      highlightDefendOptionsForPlayer();
    }
  } else {
    endBout(true);
  }
}
function canThrow(who){
  // можно подкидывать, если на столе есть карты (атака/защита) и у защитника есть место
  if(G.table.length===0) return false;
  const ranks = new Set();
  G.table.forEach(p=>{ ranks.add(p.attack.r); if(p.defense) ranks.add(p.defense.r); });
  const hand = G.hands[who];
  return hand.some(c=>ranks.has(c.r));
}

/* ================== Защитник берёт ================== */
function defenderTake(who){
  const takeCards = [];
  G.table.forEach(p=>{ if(p.attack) takeCards.push(p.attack); if(p.defense) takeCards.push(p.defense); });
  takeCards.forEach(c=>G.hands[who].push(c));
  log(`${who==='you'?'Вы':'Бот'} взял ${takeCards.length} карт(ы).`);
  renderHands(); renderBotHand();
  ui.board.innerHTML = '';
  G.table = [];

  // добор до 6: сначала атакующий, затем взявший
  refillOrder([G.attacker, who]);

  // атакующим остаётся тот же игрок
  G.defender = (G.attacker==='you')?'bot':'you';
  G.phase='attack'; updateHeader();
  checkEnd();

  if(!G.finished){
    if(G.attacker==='bot') setTimeout(botAttackStart, 600);
    else highlightAttackOptionsForPlayer();
  }
}

/* ================== Конец взятки (отбой) и добор ================== */
function endBout(defenseSucceeded){
  // отбой: карты уходят в сброс
  flyToDiscardFromBoard();
  G.table.forEach(p=>{ if(p.attack) G.discard.push(p.attack); if(p.defense) G.discard.push(p.defense); });
  G.table = [];

  // добор до 6: сначала атакующий, затем защитившийся
  refillOrder([G.attacker, G.defender]);

  // следующий ход: если защита удалась — атакует прежний защитник
  if(defenseSucceeded){
    const next = G.defender;
    G.attacker = next;
    G.defender = (next==='you')?'bot':'you';
    log(`Отбой. Атакует: ${G.attacker==='you'?'Вы':'Бот'}.`);
  }

  G.phase='attack'; updateHeader();
  checkEnd();

  if(!G.finished){
    if(G.attacker==='bot') setTimeout(botAttackStart, 600);
    else highlightAttackOptionsForPlayer();
  }
}
function refillOrder(order){
  for(const who of order){
    while(G.hands[who].length<6 && G.deck.length){
      const c = G.deck.shift();
      G.hands[who].push(c);
      if(who==='you'){
        const el = cardEl(c); el.classList.add('dealing'); ui.hand.appendChild(el);
        const deckBox = ui.deck.getBoundingClientRect();
        const box = el.getBoundingClientRect();
        const dx = (deckBox.left + deckBox.width/2) - (box.left + box.width/2);
        const dy = (deckBox.top  + deckBox.height/2) - (box.top  + box.height/2);
        el.style.transition = 'transform .35s ease, opacity .35s ease';
        requestAnimationFrame(()=>{
          el.style.transform = `translate(${dx}px,${dy}px) scale(.95)`; el.style.opacity = '0';
          setTimeout(()=>{
            el.style.transform = 'translate(0,0) scale(1)'; el.style.opacity = '1';
            setTimeout(()=>el.classList.remove('dealing'), 150);
            el.onclick = ()=>onCardClick(c);
          }, 20);
        });
      }
    }
  }
  updateHeader();
}

/* ================== Подсветки и доступные действия ================== */
function highlightAttackOptionsForPlayer(){
  ui.btnAttack.disabled=true; ui.btnThrow.disabled=true; ui.btnDefend.disabled=true; ui.btnTake.disabled=true; ui.btnPass.disabled=true;
  Array.from(ui.hand.children).forEach(el=>el.classList.remove('disabled','selectable'));
  // на первой атаке — любые карты
  G.phase='attack'; updateHeader();
}
function highlightDefendOptionsForPlayer(){
  ui.btnAttack.disabled=true; ui.btnThrow.disabled=true; ui.btnDefend.disabled=true; ui.btnTake.disabled=false; ui.btnPass.disabled=true;
  const idx = G.table.findIndex(p=>!p.defense);
  if(idx<0){ ui.btnTake.disabled=true; return; }
  const att = G.table[idx].attack;
  Array.from(ui.hand.children).forEach(el=>{
    const id = el.dataset.id;
    const c = G.hands.you.find(x=>x.id===id);
    const ok = beats(att,c,G.trump);
    if(!ok){ el.classList.add('disabled'); el.classList.remove('selectable'); }
    else { el.classList.remove('disabled'); el.classList.add('selectable'); }
  });
}
function highlightThrowOptions(who){
  ui.btnAttack.disabled=true; ui.btnDefend.disabled=true; ui.btnTake.disabled=true; ui.btnPass.disabled=false;
  const ranks = new Set(); G.table.forEach(p=>{ ranks.add(p.attack.r); if(p.defense) ranks.add(p.defense.r); });
  const list = who==='you' ? Array.from(ui.hand.children) : Array.from(ui.botHand.children);
  list.forEach(el=>{
    const id = el.dataset.id; const hand = G.hands[who]; const c = hand.find(x=>x.id===id);
    const ok = ranks.has(c.r) && G.table.length < G.hands[G.defender].length;
    if(who==='you'){
      if(ok){ el.classList.add('selectable'); el.classList.remove('disabled'); }
      else  { el.classList.add('disabled'); el.classList.remove('selectable'); }
    }
  });
}

/* ================== Хелперы рук ================== */
function removeFromHand(who, card){
  const i = G.hands[who].findIndex(c=>c.id===card.id);
  if(i>=0) G.hands[who].splice(i,1);
  // удалить из DOM (у игрока)
  if(who==='you'){
    const el = ui.hand.querySelector(`[data-id="${card.id}"]`); if(el) el.remove();
  } else {
    const el = ui.botHand.querySelector(`[data-id="${card.id}"]`); if(el) el.remove();
  }
}

/* ================== Завершение игры ================== */
function checkEnd(){
  const youEmpty = G.hands.you.length===0;
  const botEmpty = G.hands.bot.length===0;
  if(G.deck.length===0 && (youEmpty || botEmpty)){
    G.finished = true;
    if(youEmpty && !botEmpty) ui.end.textContent = 'Победа! Вы вышли из карт.';
    else if(botEmpty && !youEmpty) ui.end.textContent = 'Поражение: бот вышел из карт.';
    else ui.end.textContent = 'Ничья (оба вышли одновременно).';
    ui.btnAttack.disabled=ui.btnThrow.disabled=ui.btnDefend.disabled=ui.btnTake.disabled=ui.btnPass.disabled=true;
  }
}

/* ================== События ================== */
ui.newGame.onclick = initGame;
initGame();
</script>
</body>
</html>
