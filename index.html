<!DOCTYPE html>
<html>
<head>
    <title>Bubble Shooter Premium</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #gameContainer {
            text-align: center;
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        #score {
            font-size: 32px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        #canvas {
            background: #f0f4f8;
            border: 3px solid #333;
            border-radius: 15px;
            display: block;
            cursor: crosshair;
        }
        #nextBubble {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            color: #666;
        }
        #nextPreview {
            width: 60px;
            height: 60px;
            margin: 10px auto;
            border: 3px solid #333;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">Очки: 0</div>
        <canvas id="canvas" width="480" height="640"></canvas>
        <div id="nextBubble">Следующий:</div>
        <div id="nextPreview"></div>
    </div>
    
    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const nextPreview = document.getElementById('nextPreview');

// Конфиг игры
const CONFIG = {
    BALL_RADIUS: 20,
    COLORS: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFD93D', '#6BCF7F', '#C77DFF'],
    ROWS: 8,
    COLS: 11,
    SHOOTER_Y: canvas.height - 40
};

let score = 0;
let balls = [];
let currentBall = null;
let nextBall = null;
let angle = -Math.PI / 2;
let shooting = false;

class Ball {
    constructor(x, y, color, row = null, col = null) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.color = color;
        this.radius = CONFIG.BALL_RADIUS;
        this.row = row;
        this.col = col;
    }
    
    draw() {
        // Тень
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.arc(this.x + 3, this.y + 3, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Основной шар
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Обводка
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Блик
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(this.x - 6, this.y - 6, 7, 0, Math.PI * 2);
        ctx.fill();
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        // Отскок от стен
        if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
            this.vx *= -1;
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        }
    }
}

function getGridPosition(x, y) {
    const row = Math.floor(y / (CONFIG.BALL_RADIUS * Math.sqrt(3)));
    const offsetX = (row % 2) * CONFIG.BALL_RADIUS;
    const col = Math.floor((x - offsetX) / (CONFIG.BALL_RADIUS * 2));
    return { row, col };
}

function getScreenPosition(row, col) {
    const offsetX = (row % 2) * CONFIG.BALL_RADIUS;
    const x = col * CONFIG.BALL_RADIUS * 2 + CONFIG.BALL_RADIUS + offsetX;
    const y = row * CONFIG.BALL_RADIUS * Math.sqrt(3) + CONFIG.BALL_RADIUS;
    return { x, y };
}

function initBalls() {
    balls = [];
    for (let row = 0; row < 5; row++) {
        for (let col = 0; col < CONFIG.COLS; col++) {
            const pos = getScreenPosition(row, col);
            if (pos.x - CONFIG.BALL_RADIUS >= 0 && pos.x + CONFIG.BALL_RADIUS <= canvas.width) {
                const color = CONFIG.COLORS[Math.floor(Math.random() * CONFIG.COLORS.length)];
                balls.push(new Ball(pos.x, pos.y, color, row, col));
            }
        }
    }
}

function createNewBall() {
    const color = CONFIG.COLORS[Math.floor(Math.random() * CONFIG.COLORS.length)];
    return new Ball(canvas.width / 2, CONFIG.SHOOTER_Y, color);
}

function shoot() {
    if (shooting || !currentBall) return;
    shooting = true;
    const speed = 12;
    currentBall.vx = Math.cos(angle) * speed;
    currentBall.vy = Math.sin(angle) * speed;
}

function findMatches(ball) {
    const matches = [ball];
    const checked = new Set();
    const queue = [ball];
    
    while (queue.length > 0) {
        const current = queue.shift();
        checked.add(current);
        
        for (const other of balls) {
            if (checked.has(other) || other.color !== ball.color) continue;
            
            const dx = current.x - other.x;
            const dy = current.y - other.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < CONFIG.BALL_RADIUS * 2.5) {
                matches.push(other);
                queue.push(other);
                checked.add(other);
            }
        }
    }
    
    return matches;
}

function checkCollision() {
    if (!currentBall || !shooting) return;
    
    // Проверка достижения верха
    if (currentBall.y - currentBall.radius <= 0) {
        snapToGrid();
        return;
    }
    
    // Проверка столкновения с другими шарами
    for (const ball of balls) {
        const dx = currentBall.x - ball.x;
        const dy = currentBall.y - ball.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < CONFIG.BALL_RADIUS * 2) {
            snapToGrid();
            return;
        }
    }
}

function snapToGrid() {
    const gridPos = getGridPosition(currentBall.x, currentBall.y);
    const screenPos = getScreenPosition(gridPos.row, gridPos.col);
    
    currentBall.x = screenPos.x;
    currentBall.y = screenPos.y;
    currentBall.vx = 0;
    currentBall.vy = 0;
    currentBall.row = gridPos.row;
    currentBall.col = gridPos.col;
    
    balls.push(currentBall);
    
    // Проверка совпадений
    const matches = findMatches(currentBall);
    if (matches.length >= 3) {
        balls = balls.filter(b => !matches.includes(b));
        score += matches.length * 10;
        scoreEl.textContent = 'Очки: ' + score;
    }
    
    // Новый шар
    currentBall = nextBall;
    nextBall = createNewBall();
    updateNextPreview();
    shooting = false;
}

function updateNextPreview() {
    if (nextBall) {
        nextPreview.style.background = nextBall.color;
    }
}

function drawAim() {
    if (shooting) return;
    
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 3;
    ctx.setLineDash([10, 5]);
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, CONFIG.SHOOTER_Y);
    ctx.lineTo(
        canvas.width / 2 + Math.cos(angle) * 200,
        CONFIG.SHOOTER_Y + Math.sin(angle) * 200
    );
    ctx.stroke();
    ctx.setLineDash([]);
}

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Рисуем шары на сетке
    for (const ball of balls) {
        ball.draw();
    }
    
    // Рисуем летящий шар
    if (currentBall) {
        if (shooting) {
            currentBall.update();
            checkCollision();
        }
        currentBall.draw();
    }
    
    // Рисуем прицел
    drawAim();
    
    requestAnimationFrame(gameLoop);
}

canvas.addEventListener('mousemove', (e) => {
    if (shooting) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    angle = Math.atan2(mouseY - CONFIG.SHOOTER_Y, mouseX - canvas.width / 2);
    
    // Ограничение угла
    angle = Math.max(-Math.PI + 0.1, Math.min(-0.1, angle));
});

canvas.addEventListener('click', shoot);

// Инициализация
initBalls();
currentBall = createNewBall();
nextBall = createNewBall();
updateNextPreview();
gameLoop();
    </script>
</body>
</html>
